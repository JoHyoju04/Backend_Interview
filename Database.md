
# 데이터베이스

## 키 종류
![데이터베이스-키](https://user-images.githubusercontent.com/47858282/214509636-3ccc4ed7-3641-4f1b-8c80-fe58b226640d.png)

- **후보키** : 유일성과 최소성을 만족한 키
    - 유일성 : 해당 키로 하나의 튜플을 식별할수있음
    - 최소성 : 튜플을 구분하는데 꼭 필요한 속성들로만 구성
- **기본키** : 후보키들 중 하나, Null 가질 수 없음, 동일한 값을 가질수없음
- **대체키/보조키** : 기본키를 제외한 후보키
- **외래키** : 다른 릴레이션의 속성, 참조 관계를 표현하는 데 키
- **슈퍼키** : 유일성은 만족하지만 최소성은 만족하지 못하는 키
<br>

## JOIN에 대해서 설명

- 2개의 테이블에 대해 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환하는 것
- 두 가지 이상의 릴레이션을 연결해서 데이터를 검색하는 기법
- RDBMS에서는 릴레이션끼리 관계를 가지고 있는데, 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.  
<br>

## 내부 조인,외부 조인,셀프 조인

**내부 조인(Inner Join)** : JOIN 조건에서 동일한 값이 있는 튜플만 반환(교집합). JOIN의 기본값으로 inner 생략 가능하며 JOIN조건인 using, on 조건절 필수적으로 사용

- 동등 조인(EQUI Join) : 공통 속성(컬럼)을 기준으로 동등 비교(=) 사용
- 자연 조인(Natural Join) : 동등조인에서 동일한 속성이 두 번 나타나게 되는데, 이 중 중복된 속성을 제거하여 반환(같은 이름을 가진 속성은 한 번만 추출된다.)
- 교차 조인(Cross Join) : 조인하는 두 테이블에 있는 튜플들의 순서쌍을 반환, 결과로 반환되는 테이블의 행의 수는 두테이블의 행 수를 곱한것과 같다. (모든 경우의 수(M*N))

**외부 조인(Outer Join)** : JOIN 조건에 만족하는 튜플 뿐만 아니라 만족하지 않는 튜플도 반환

- Left Outer Join : 왼쪽 테이블을 기준으로 왼쪽 테이블의 모든 결과값 포함해서 반환
- Right Outer Join : 오른쪽 테이블을 기준으로 오른쪽 테이블의 모든 결과값 포함
- Full outer join
- 기준이 되지않은 테이블에 값이 없으면  NULL값을 가진다.

**셀프 조인 (Self Join)** : 같은 테이블인 (2개의 속성을 연결하여) 자기 자신과 JOIN 방법, 컬럼 이름이 모두 동일하기 때문에 별칭 필수

![sql](https://user-images.githubusercontent.com/47858282/232713540-26b74cdd-66ed-47c5-b139-46981405fb6f.png)
<br>
<br>

## SQL Injection이란

해커에 의해 조작된 쿼리문이 DB에 그대로 전달되어 잘못된(비정상적) 명령을 실행시키는 공격 기법.  
예시 : Error based SQL Injection
![데이터베이스 - sql injection](https://user-images.githubusercontent.com/47858282/214509835-84701d20-d57b-4de7-a1d4-605dfc8a4d5a.png).  
해결방안 : 입력값에 의한 에러 검증,에러 메시지 노출하지 않는다.
<br>
<br>

## 파티셔닝과 샤딩에 대해서 설명

- **파티셔닝**
    - 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것
    - 대용량 DB의 경우 중요한 몇개의 테이블에만 집중되어 데이터가 증가하면 용량과 성능 측면에서 이슈가 발생할 때 이 기법을 통해 해결할 수 있다.
    - X테이블의 일부 데이터는 A에, Y테이블의 일부 데이터는 B에
    
- **수평 단편화/수평 파티셔닝/샤딩**
    - 데이터를 수평으로 쪼갠다

- **수직 단편화/수직 파티셔닝**
    - 테이블의 칼럼을 기준으로 쪼갬
    - 칼럼을 나눠서 새로운 테이블로 갖고있는 것
    - 특정 컬럼이 빈번하게 참조될때, 여러 데이터가 캐시에 올라갈수있음

- 수평 파티셔닝과 샤딩의 차이점

수평 파티셔닝은 **같은 데이터베이스 내에서** 하나의 큰 테이블을 쪼개 분산 저장하는 기법이다.

반면, 샤딩은 하나의 큰 테이블을 쪼개 **각각 다른 데이터베이스에** 분산 저장하는 기법이다.
<br>
<br>

## ORM(Object Relational Mapping)이란

- 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것
    - 객체 모델과 관계형 모델 간의 불일치가 존재하므로 이를 해결
    - ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성
- 장점
    - 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있다.→ myBatis나 JDBC에서는 SQL 문에 종속적이다.
    - 재사용 및 유지보수의 편리성이 증가한다.
- 단점
    - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
    - queryDSL
<br>
<br>

## NoSQL이란

비관계형 데이터베이스를 말하며 RDBMS와 달리 데이터간의 관계를 정의하지 않는다.

- 장점
    - 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있다.
    - 언제든 저장된 데이터를 수정하고 새로운 필드를 추가할 수 있다.
- 단점
    - 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경 될 경우 수정을 모든 컬렉션에서 수행을 해야한다.
    - 스키마가 존재하지 않기 때문에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정하기가 어려울 수 있다.
<br>
<br>

## 스키마란

- 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터 집합
- 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.
<br>
<br>

## View란

- 하나 이상의 테이블에서 유도된, 매모리에 물리적으로 존재하지 않는 가상 테이블
- 특정 사용자로부터 특정 속성을 숨기는 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용
- 인덱스를 가질 수 없고, 뷰의 정의를 변경할 수 없음
- 기본 키 포함해서 정의해야만 삽입, 삭제, 갱신 연산 가능
<br>
<br>

## 이상현상이란 무엇인가요?

데이터의 중복으로 인한 부작용을 말합니다

- 삽입 이상 : 불필요한 데이터를 추가해야만 삽입이 가능한 상황
- 갱신 이상 : 전체의 데이터 중 일부만 변경하여 데이터가 불일치하는 상황
    - 예시 :학번,지도교수,수강과목이 있을 때 해당 학번의 지도교수가 변경되면 해당 학번에 대한 모든 행의 지도교수가 바뀌어야한다.
- 삭제 이상 : 삭제로 인해 꼭 필요한 데이터까지 삭제되는 상황
<br>
<br>

## 정규화란 무엇인가요?

중복 최소화를 위해 **테이블을 분리하는 작업**

장점

- 이상현상 해결
- 새로운 속성의 추가로 인해 DB 구조를 확장하는 경우, 구조의 변경을 최소화할 수 있다. 따라서 DB와 연동된 응용프로그램에 최소한의 영향만을 미쳐 응용프로그램의 생명을 연장시킨다.
- 정규화된 릴레이션 간의 관계가 현실 세계에서의 개념들간의 관계를 잘 보여준다.

단점

- 릴레이션 간의 연산(Join)이 많아질 수 있어 성능 저하
<br>
<br>

## 정규화의 종류

- 1 정규화 : 테이블의 컬럼이 하나의 값을 갖도록 테이블을 분해하는 것( = 도메인이 원자값만 포함)
- 2 정규화 : 기본키의 부분집합이 결정자가 안되도록 분리( = 완전 함수적 종속이 되어야한다 = 기본키중에 특정컬럼에만 종속되지 않아야한다.
- 3 정규화 : 기본키를 제외한 이행적 종속 제거 (a -> b, b -> c 일때, a->c 가 성립되는 것을 분리, 즉, a-> b랑 b->c 테이블로 분리)
- BCNF(Boyce-Codd Normal Form) : 값을 정하는 결정자가 후보키가 되도록 테이블 분해(모든 결정자가 후보키)
<br>
<br>

## 함수적 종속성

db에서 속성들간 종속관계를 말한다.
`X → Y`
 : 릴레이션 R에서 X값을 알면 Y를 알 수 있고, X 값에 의해 Y값이 달라질 때, Y는 X에 함수적 종속이다.
X를 결정자,Y를 종속자라고 한다.
<br>
<br>

## 반정규화

반정규화는 성능 향상을 위해 중복,통합을 하는 기법이다.
조인으로 인한 성능 저하가 예상되는 경우 반정규화를 실행한다.
반정규화를 과도하게 적용하면 무결성이 깨질수있다.
<br>
<br>

## 인덱스란?
- 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장되는 자료구조
- 데이터베이스의 테이블에 대한 검색 속도 향상시켜줌
- 일반적으로 B+ 트리 자료구조를 사용
- 단점
    - 데이터의 추가, 삭제, 수정의 경우 인덱스도 변경하고 정렬해야 하므로 성능 저하
    - 추가적인 저장 공간 필요
<br>
<br>

## 인덱스를 사용하는 이유
- where절의 조건에 맞는 데이터를 찾을 때 full scan을 해야한다. 하지만 인덱스는 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건에 만든 데이터들을 빠르게 찾아낼 수 있다.
<br>
<br>

## 인덱스 설계시 고려할 점
인덱스 관리(정렬된 상태 유지)를 위해서는 추가 작업이 필요하기 때문에 인덱스가 많을 수록 성능이 좋은 것이 아니다. 그러므로 아래 사항을 고려한다.
- 고유한 값을 많이 가지는 Column(Primary Key)을 인덱스로 사용한다.
- ISERT, DELETE, UPDATE 가 자주 발생하지 않은 Column을 인덱스로 사용한다
- JOIN, WHERE, ORDER BY 에 자주 사용되는 Column을 인덱스로 사용한다
- 데이터 중복도가 낮은 Column을 인덱스로 사용한다
<br>
<br>

## 인덱스의 자료구조

- 해시 테이블(Hash Table) : key와 value값으로 한 쌍으로 데이터를 저장,key 값을 컬럼의 값,value를 데이터 주소로 저장된다.
- B-트리 : 이진트리를 확장해서 많은 자식 노드를 가질 수 있는 균형트리(뎁스가 길지 않기 때문에)로 key들이 항상 정렬되어 있다.
- B+ 트리 : B-트리의 모든 데이터를 한 번 순회하는데 트리의 모든 노드를 방문해야하는 단점이 있습니다. 개선시킨 자료구조로 오직 leaf 노드(자식 노드가 없다)에만 데이터를 저장한다.
<br>
<br>

## 인덱스에 hash table이 아닌 b+tree 를 사용하는 이유는 무엇인가요?

해시테이블은 부등호 연산에 최적화되어있지 않다. 데이터베이스에 부등호 연산을 할 때 해시테이블 내의 데이터들은 정렬되어 있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내에 찾을 수가 없다.

반면에 B+트리는 부등호 연산이 가능하다.(B-트리도 부등호 연산이 가능하나 부등호 연산시에 모든 트리의 노드를 순회해야한다. B+트리는 링크드 리스트로 연결되어 있기 때문에 데이터가 저장된 리프노드만 순회하면 된다.)
<br>
<br>

## Full Table Scan과 Index Scan을 설명

- Full Table Scan
    - 테이블에 존재하는 모든 데이터를 읽어가면서 사용자가 원하는 데이터를 찾는다.
- Index Range Scan
    - 인덱스 루트부터 리프노드까지 수직적으로 탐색하는 방법
    - 선두 컬럼을 가공하지 않은 상태로 조건절에 사용해야 한다.
- Index Full Scan
    - 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식
    - 데이터 검색을 위한 최적의 인덱스가 없을때 차선으로 선택(예를 들면 인덱스가 여러개일때 where절에 선두컬럼이 없으면 다른 컬럼이 인덱스에 있을 경우 인덱스 풀 스캔을 통해 검색한다.
<br>
<br>

## 클러스터 인덱스와 넌클러스터 인덱스란?

**클러스터 인덱스**
- 한 테이블당 1개(Primary Key)만 허용
- 기본 키 설정시 자동으로 만들어집니다.
- 테이블 자체가 인덱스(클러스터 인덱스를 기준으로 테이블을 정렬하기 때문에 인덱스 페이지가 없다)
- 데이터 입력,수정,삭제 시 항상 정렬을 유지함
- 기본적으로 접근 성능이 좋음

**넌클러스터 인덱스(사용자가 만든 인덱스이다.)**
- 테이블 당 최대 240개 생성 가능
- 인덱스 페이지를 별도로 저장
- 테이블 자체는 정렬되지 않고,인덱스 페이지에만 정렬
<br>
<br>

## 트랜잭션이란? (4가지 특징을 포함)

**데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위**

논리적인 작업의 쿼리 개수와 관계 없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장

- 특징
    - Atomicity(원자성)
      트랜잭션을 구성하는 모든 연산이 정상적으로 실행되거나 모두 취소되어야 한다.
    - Consistency(일관성)
      트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지한다.
    - Isolation(고립성,격리성)
      두 개 이상의 트랜잭션이 동시에 발생할 때, 서로의 연산에 영향을 주면 안된다.
    - Durability(영구성)
      커밋된 트랜잭션의 내용은 영구히 반영된다.
<br>
<br>

## 트랜잭션의 격리 수준과 각 수준에서 발생할 수 있는 문제들에 대해 말해보세요

- **Read Uncommitted**
    - 다른 트랜잭션에서 커밋되지 않은 내용에 접근 가능
    - 문제
        - Dirty Read, Non-Repeatable Read, Phantom Read가 일어날 수 있음
    - 락 발생 X
- **Read Committed**
    - 커밋된 내용만 접근 가능
    - 문제
        - Non-Repeatable Read가 발생
    - 락 발생 X
- **Repeatable(반복가능한) Read**
    - 커밋이 완료된 데이터만 읽을 수 있으며, 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장
    - 문제
        - 일정범위의 레코드를 두번 이상 읽을 때, 첫 번재 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 Phantom read
    - 락 발생
- **Serializable**
    - 가장 엄격한 트랜잭션 격리 수준
    - Phantom read가 발생하지 않음.
    - 동시성 처리 성능이 급격히 떨어질 수 있음.

Mysql 의 **InnoDB** 스토리지 엔진의 기본 Isolation Level이 REPEATABLE-READ 이고 Oracle 은 READ-COMMITED 입니다.
<br>
<br>

## 공유 락과 배타 락의 차이는?
**공유(Shared) Lock→for share**
    - 공유 Lock은 데이터(row)를 읽을 때 사용되는 Lock
    - 공유Lock끼리 동시에 접근이 가능합니다. 즉, 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다.
    - 하지만 공유Lock이 설정된 데이터에 베타Lock을 사용할 수는 없다.

**베타(Exclusive) Lock→for update**
    - 베타 Lock은 데이터를 변경하고자 할 때 사용
    - Lock이 해제 될때까지 다른 공유락,베타락을 설정할 수 없다.
<br>
<br>

## 교착상태(데드락)이란 무엇이며, 어떻게 발생?
두 트랜잭션이 각각 Lock을 설정한 다음 서로의 Lock에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 Lock이 설정되어 있기 때문에 양쪽 트랜잭션 모두 처리되지 않게 되는 상태(서로 무한정 기다리는 상태)

(상황 예시)1) Shared Lock + Exclusive Lock
= 트랜잭션 A가 Shared Lock을 설정하고 sleep 되었을때, 트랜잭션 B가 해당 데이터에 Exclusive Lock을 걸려고 하면 무기한 기다려야하는 교착상태에 빠지게된다.
2) Exclusive Lock + Exclusive Lock
= 트랜잭션 A에서 Exclusive Lock을 걸었을때 트랜잭션 B에서도 다른 데이터에 Exclusive Lock을 걸었다. 이 경우 서로의 Lock된 데이터에 접근하려고할 때 기존의 Lock이 해제될 때까지 기다리게된다.

해결: 
1. Dead Lock이 감지되면 둘 중 하나의 트랜잭션을 강제 종료한다
실제로, Oracle 에서는 데드락이 감지되면 한쪽 Transaction을 강제로 풀어버린다
이렇게 되면 하나의 트랜잭션A의 마지막 실행 내용에 오류가 발생되고 커밋이 발생되도록 유지한다
또 다른 트랜잭션 B는 아직 대기중이며, 트랜잭션 A의 커밋을 기다린다
2. 베타 락의 사용을 피한다.
<br>
<br>

## Commit과 Rollback이란 무엇인가?
- Commit
    - 트랜잭션이 성공하여 트랜잭션 결과를 영구적으로 반영하는 연산
- Rollback
    - 트랜잭션의 실행을 취소하였음을 알리는 연산
    - 트랜잭션이 수행한 결과를 원래의 상태로 복구시키는 연산
    - →이전 상태가 언제까지?트랜잭션의 시작시점
