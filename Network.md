
# 네트워크

## OSI 7계층

국제표준화기구에서 네트워크 간의 호환을 위해 OSI 7계층이라는 표준 네트워크 모델

- Application(응용) 계층 : **최종 목적지로 응용 프로그램과 연관하여 서비스를 수행하는 계층**
  - ex) HTTP, FTP, DNS
- Presentation(표현) 계층 : **데이터 압축, 변환이 이뤄지는 계층**
  - ex) JPEG, MPEG
- Session(세션) 계층 : **데이터가 통신하기 위한 논리적 연결을 담당하는 계층**
    - ex) API, Socket
- Transport(전송) 계층 : **종단 간의 사용자들에게 신뢰성 있는 데이터를 전달하는 계층**
    - 흐름 제어 : 송신측과 수신측 사이의 데이터 처리 속도 차이를 제어
    - 혼잡 제어 : 네트워크 혼잡을 피하기 위해 데이터의 전송 속도 제어
    - 오류 제어 : 오류 검출과 재전송
- Network(네트워크) 계층 : **IP를 지정하고 라우터로 경로를 선택해 네트워크를 통해 패킷을 전달하는 계층**
- Data Link(데이터링크) 계층 : 물리적으로 연결된 호스트 사이에 **신뢰성 있는 전송하는 계층**
    - 오류 제어, 흐름 제어, 회선 제어
- Physical(물리) 계층 : **전기적, 물리적 세부 사항을 정의하는 계층**

전송계층은 논리적으로 1:1 연결된 송신과 수신 호스트 즉, 종단간의 호스트에 신뢰성 관련 기능을 제공하고, 데이터 링크 계층은 물리적으로 1:1 연결된 호스트 사이의 전송 즉, 직접 묶여있는 호스트-노드 또는 노드-노드 사이에서의 신뢰성 관련 기능을 제공한다.

## 계층을 나눈 이유 

통신이 일어나는 과정을 단계별로 알 수 있고, 문제가 생기면 그 단계만 수정하면 된다.

## TCP/IP 4계층

**TCP/IP 4계층은, TCP/IP 프로토콜 통신 과정에 초점을 맞추어, OSI 7계층을 좀 더 단순화 시킨 계층을 의미합니다.**

네트워크 인터페이스 계층 : 물리+데이터링크 계층, MAC주소 사용

인터넷 계층: 네트워크 계층, 통신 노드간의 IP패킷을 전송하는 기능과 라우팅 기능 담당

Transport layer(전송 계층) : 전송 계층, 통신 노드간의 연결 제어 및 신뢰성 있는 데이터 전송 담당

Application layer(응용 계층) : 세션+표현+응용 계층, 응용 프로그램 구현

참고:

TCP/IP Updated의 **5계층 모델**은 네트워크 인터페이스 계층을 다시 두 레이어로 세분화하고, `Internet`명칭을 `Network`로 다시 변경했다는 차이가 있다. **TCP/IP Updated**모델은 현재 전 세계 표준으로 적용되고 있다.

## TCP와 UDP의 차이

**TCP**

- 연결형 프로토콜로 신뢰성 있는 데이터 전송을 지원
- 흐름제어, 혼잡제어, 오류제어 지원
- 연결 설정시 3 way handshake를, 연결 해제시 4 way handshake 진행
- UDP보다 속도가 느리다
- **EX)** 웹 http 통신, 이메일, 파일 전송

**UDP**

- 비연결형 프로토콜로 데이터를 데이터그램 단위로 처리한다.
- 신뢰성 낮음
- 속도가 빠르고 부하가 적다
- **EX)** Real Time Protocol(RTP), Multicast, DNS


## 유니캐스트, 멀티캐스트, 브로드캐스트란?

- 유니캐스트
  - 특정 대상과 1:1 통신
- 멀티캐스트
  - 특정 다수와 1:N 통신
  - 대상에 대해 선택적으로 데이터를 전송
- 브로드캐스트
  - 특정한 대상이 아닌 자신이 속한 네트워크 내의 모든 장비들과 통신
- 애니캐스트
  - 1:1 통신으로 유니캐스트와 비슷하지만 다른 점으로는 네트워크에 연결된 수신 가능 한 장비 중에서 가장 가까운 한 노드에만 전송
  - IPv6 기반으로 작동


## 흐름제어 / 혼잡제어 / 오류제어

- **흐름제어**는 송신측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위한 기법입니다.

- **혼잡제어**는 송신측의 데이터 전달과 처리 속도 차이를 해결하는 기법입니다.

- **오류제어**는 패킷이 잘못 전달됐을 경우 패킷을 재전송하는 등 오류를 복구하는 기법입니다.


## DNS(Domain Name System)

IP주소와 문자로 표현한 주소를 매핑해주는 시스템 혹은 서버

## 3-way hand shake, 4-way hand shake

### 3 way handshake

- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 **연결을 설정(Connection Establish)**하는 과정
- SYN(Synchronize Sequence Number)
- ACK(Acknowledgement)
1. **클라이언트** → **서버** : 서버 접속 요청 **SYN 패킷** 보냄
2. **서버** → **클라이언트** : 요청 수락 응답 **ACK 패킷**과 포트 열어달라는 **SYN 패킷** 보냄
3. **클라이언트** → **서버** : 확인 응답으로 **ACK 패킷** 보냄


### 4 way handshake
![4wayhandshake](https://user-images.githubusercontent.com/47858282/225514615-4ae9b610-4570-4cb3-a5cb-cbf95d9841ef.png)

HTTP 요청과 응답 과정이 끝나면 연결과정을 종료하는 4-way-handshaking이 진행된다.

1. 클라이언트가 서버로 연결을 종료하겠다는 FIN 패킷 전송
2. 서버는 클라이언트에게 우선적으로 ACK 패킷 전송
3. 서버는 자신의 통신이 끝날 때까지 기다리고 끝나면 클라이언트에게 FIN 패킷 전송
4. 클라이언트는 확인했다는 의미로 ACK 패킷을 서버에게 전송
5. 서버에서 FIN보다 데이터가 늦게 보내질 경우를 대비해 클라이언트는 일정 시간 동안 소켓을 닫지 않고 잉여 패킷을 기다림(time wait)
6. 이후에 연결 종료

## www.google.com에 접속할때 일어나는 일에 대해 설명해주세요.
![google](https://user-images.githubusercontent.com/47858282/225515112-1002d9cf-d037-4ca4-a21c-6cb421650c25.png)

1. 사용자가 www.google.com 을 웹 브라우저 주소창에 입력한다.
2. 브라우저는 캐싱된 DNS 기록을 통해 www.google.com 에 대응되는 IP 주소가 있는지 확인한다.
  - 브라우저 캐시 확인
  - OS 캐시 확인
  - 라우터 캐시 확인
  - ISP 캐시 확인
3. 요청한 URL이 캐시에 없으면 ISP(인터넷 서비스 제공자, kt 등)의 DNS 서버가 www.google.com 을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날려서 찾는다.
4. 브라우저는 IP주소를 받아 서버와 TCP 연결을 한다. (3 way handshaking)
  - 클라이언트가 서버로 접속 요청 SYN 패킷을 보낸다.
  - 서버에서는 수락하는 ACK와 SYN 패킷을 보낸다.
  - 클라이언트는 서버에게 확인 응답으로 ACK 패킷을 보낸다.
5. TCP 연결이 완료되면 브라우저가 웹 서버에 HTTP 요청을 보낸다.
6. 서버는 요청을 처리하고 response를 생성하고 보낸다.
7. 브라우저가 HTML content를 사용자에게 보여준다.

서버단에서 클라이언트 단으로 index.html을 응답으로 보내게 되는데 여기 안에는 구글의 이미지 google.png가 들어있다.웹 브라우저는 html파일을 읽어서 해석하는데 이미지 주소가 나오면 다시 해당 url로 서버에 요청을 보내고 위와 같은 요청을 반복한다.

## 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.

**Recursive Query를 통해 접근 : Local DNS 서버 -> Root DNS 서버 -> (최상위 도메인)com DNS 서버 -> naver.com DNS 서버**

1. 로컬 DNS서버에 해당 url이 등록되어있는지 확인
2. 루트 DNS서버에 문의 후 최상위 도메인 .com이 등록된 네임 서버의 IP주소 전달
3. 로컬 DNS서버는 com DNS 서버에 해당 url을 문의함. 로컬 DNS서버에 naver.com DNS 서버의 IP 주소 알려줌
4. naver.com에 해당 url 문의함. 로컬 DNS는 IP 주소를 받을수있음

Root DNS는 최상위 DNS서버로 해당 DNS부터 시작해서 아래 딸린 node DNS서버에게로 차례차례 물어보게 됩니다.

## HTTP 프로토콜에 대해서 말해주세요.

- HTTP 프로토콜의 특징
  - 비연결성(connectionless) : 실제로 요청을 주고 받을때만 연결을 유지하는 것으로, 응답을 주고 나면 TCP/IP 연결을 끊는다. 이를 통해 최소한의 자원으로 서버 유지를 가능하게 한다.
  - 무상태 프로토콜(stateless) : 서버가 클라이언트의 상태를 보존하지 않는 것
- HTTP
  - 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜
  - TCP(HTTP/1, HTTP/2), UDP(HTTP/3)를 사용하며, 80번 포트를 사용한다.


## HTTP와 HTTPS 의 차이는 무엇인가요?

HTTP는 인터넷 상에서 클라이언트와 서버가 자원을 주고받기 위한 통신규약인데, 텍스트로 자원을 주고받기 때문에 네트워크를 가로챈다면 내용이 유출되는 보안 이슈가 발생할 수 있습니다.

이를 해결하는 것이 HTTPS입니다.

HTTPS에 SSL 프로토콜을 사용해 정보를 암호화하는데, 메모리나 리소스를 더 많이 쓸 수 있다는 특징이 있습니다.

- HTTPS
  - **HTTP의 보안상 문제를 해결하기 위해 등장한 프로토콜**
  - HTTP는 텍스트로 자원을 주고받기 때문에 네트워크를 가로챈다면 내용이 유출되는 보안 이슈가 발생한다.
  - SSL, TLS(SSL의 최신 버전)를 이용해 암호화하여 주고받음
    - 응용 계층 및 전송 계층 사이에 위치
  - 443 포트 사용
  - 모든 HTTP 요청과 응답 데이터는 네트워크로 보내기지 전에 **전송 계층과 응용 계층 사이에서 암호화** 된다.
  - **HTTP 자체를 암호화하는 것이 아니라 운반하는 HTTP Body 부만 암호화를 진행하고 Header는 암호화하지 않는다.**
  - **암호화 통신 방법 (공개키/개인키, 대칭키 방식을 혼합해서 사용)**
    1. A에서 B로 접속 요청
    2. B에서 공개키를 A에게 전달
    3. A는 자신의 대칭키를 공개키 A로 암호화해서 B에게 전달
    4. B는 개인키로 복호화하여 A의 대칭키를 얻음
    5. 얻어낸 대칭키를 이용하여 A와 B가 암호문을 주고 받음
  

     공개키와(Public Key)와 비밀키(Private Key):공개키는 모두가 볼 수 있는 키이며 비밀키는 소유자만이 가지고 있는 키로 암/복호화에 사용된다.

     대칭키 암호화: 서버와 클라이언트가 암호화/복호화에 동일 비밀키를 사용하는 방식, 키를 공유하는데 어려움이 있으나 속도가 빠르다.

     비대칭키 암호화: 서버와 클라이언트가 암호화/복호화에 각각 다른 비밀키를 사용하는 방식, 공개키를 통해서 암호화를 하고 비밀키를 통해서 복호화를 한다. 공개키는 공개해도 상관없으니 키 관리에 어려움이 없으나 속도가 느림.

## HTTP Method 종류 및 역할

- GET
  - 조회, 리소스 요청
- POST
  - 요청된 데이터 처리
  - 자원을 생성
- PUT→멱등성이 보장
  - 요청된 자원이 없으면 생성
  - 요청된 자원을 새 것으로 전체 갱신
- PATCH
  - 자원의 일부분만 수정
- DELETE
  - 요청된 자원 삭제

## HTTP GET과 POST의 차이는 무엇인가요?

- GET : 정보 요청, body에 담지않고 쿼리로 전송, 캐싱가능
- POST : 데이터를 body에 담아서 리소스를 생성하거나 변경

## HTTP 1.0 vs HTTP 1.1

- HTTP 1.0
  - 요청마다 TCP 커넥션을 맺고 끊음을 반복한다.
  - 요청1 -> 응답1 -> 요청2 -> 응답2 순으로 순차적으로 진행된다. 즉, 응답을 받아야만 다음 작업을 한다.
- HTTP 1.1
  - 매 요청마다 TCP 커넥션을 맺고 끊음을 반복하지 않고 keep-alive를 통해 일정 시간 동안 커넥션을 유지한다.
  - 클라이언트는 각 요청에 대한 응답을 기다리지 않고 여러개의 요청을 연속적으로 보낸다.(파이프라이닝) 하지만 각 응답의 처리는 순차적으로 처리된다.
- HTTP/2.0
  - 하나의 커넥션으로 동시에 여러 개의 메세지를 주고 받을 수 있으며, response는 순서에 상관없이 stream으로 주고받는다.
  - 서버는 클라이언트의 요청에 대해 요청하지 않은 리소스를 마음대로 보낼 수 있다.
  - Header의 내용과 중복되는 필드를 재전송하지 않아 데이터를 절약한다.

## CORS란 무엇인가요?

다른 Origin으로 요청을 보내기 위해 지켜야 하는 정책으로, 원래대로라면 SOP에 의해 막히게 될 요청을 풀어주는 정책,
브라우저가 자신이 보낸 요청 및 서버로부터 받은 응답의 데이터가 CORS 정책을 지키는지 검사하여 안전한 요청을 보낸 건지 검사

## MTU(Maximum Transmission Unit)가 무엇인가요?

패킷이나 프레임의 최대 크기로 데이터의 크기가 크다면 단편화해야 한다.

## 쿠키와 세션

- 쿠키
  - **클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일**
- 세션
  - **일정 시간 동안 같은 브라우저로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 유지하는 것**
  - 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.
- 세션과 쿠키의 차이점
  - 저장 위치
    - 쿠키는 클라이언트, 세션은 서버
  - 라이프 사이클
    - 쿠키는 만료시간까지 유지, 세션은 브라우저 종료 시 삭제
  - 속도
    - 세션은 정보가 서버에 있기 때문에 처리가 요구되어 쿠키가 더 빠르다.
  - 보안
    - 쿠키는 클라이언트 로컬에 저장되어 취약하지만, 세션은 서버에서 관리해서 비교적 안전
- 세션보다 주로 쿠키를 사용하는 이유
  - 세션은 서버의 자원을 사용하기 때문에 사용자가 많을수록 소모되는 자원이 상당하기 때문

# REST API에 대해서 설명해 주세요.

**REST는 HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 자원을 처리하도록 설계된 아키텍처이다.**

REST를 기반으로 만든 API를 REST API라고 한다.

RESTful은 REST 아키텍처를 구현하는 웹서비스를 나타내는 것으로 REST 원리를 따르는 시스템을 RESTful이라고 한다.

HATEOAS라는 개념이 있는데, 동적인 API를 제공할 수 있게 된다.

**모든 관련된 동작**을 URI를 통해 알려주어, 클라이언트가 API의 변화에 일일이 대응하지 않아도 된다는 장점이 있다.

HTTP를 기반으로 동작하다보니 HTTP의 이점을 그대로 가져올 수 있다.(무상태, 캐시처리 등등..)

## RESTful

REST의 원리를 따르는 시스템을 말합니다.


RESTful하지 못한 경우로는 (1) CRUD 기능을 POST로만 처리하는 경우나 (2) URI에 resource, id 외의 정보가 들어가는 경우입니다.

## SNI 필드 차단

SNI 필드는 서버의 어떤 도메인이 브라우저에서 handshake 과정에서 연결되는지 나타내는 필드입니다.

서버와 클라이언트가 완전히 암호화 통신을 하기전에, 클라이언트가 요청하는 서버의 도메인이 평문으로 나타나는 SNI 필드를 이용해서 클라이언트가 접속하고자 하는 서버의 도메인을 확인한 후 차단한다.

## 로드 밸런서 / 로드 밸런싱은 무엇인지 설명하세요.

서버에 가해지는 부하를 분산해주는 장치 또는 기술을 말한다.

클라이언트와 서버풀(분산 네트워크를 구성하는 서버들의 그룹) 사이에 위치하며, 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해준다.

로드 밸런서는 로드 밸런싱 기술을 제공하는 서비스 또는 장치이다.

## WebRTC(Web Real-Time Communication)

웹,앱(안드로이드,IOS)에서 별도의 소프트웨어 없이 카메라, 마이크 등을 사용해서 실시간 커뮤니케이션을 제공하는 기술

-음성, 영상 미디어 혹은 텍스트, 파일 같은 데이터를 P2P 방식으로 전송

-화상통화,화상 공유 등을 구현할 수 있다.

## 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?


**웹 서버**

- 항상 동일한 데이터를 주는 정적 콘텐츠를 제공
- 동적 콘텐츠 제공을 위해 WAS에 클라이언트의 요청을 보내고 결과를 클라이언트에게 전달
- 정적 콘텐츠만 처리해 서버 부담을 줄임
- (Ex. Apache Server, Nignx, ...)

**웹 어플리케이션 서버(WAS)**

- 동적인 컨텐츠를 제공
- DB 접속/트랜잭션 관리/비즈니스 로직 수행
- 요청에 맞는 콘텐츠를 제공하기 위해 필요함, 단순한 정적 콘텐츠는 웹 서버에 맡겨 부하를 줄임
- 대표적인 예시로는 (Ex. Tomcat, JBoss, Jeus, ...)