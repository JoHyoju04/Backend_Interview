# 운영체제(OS)

## 프로세스와 스레드의 차이

- 프로세스
  - **컴퓨터에서 실행중인 프로그램**
  - **각자 고유한 공간과 자원을 할당받는다.**
  - 각각의 code, data, stack, heap 영역을 보유
  - 각각의 영역을 갖기에 동기화 작업이 필요하지 않음
  - 각각의 영역을 갖기에 컨텍스트 스위칭 비용이 크다.
- 스레드
  - **한 프로세스의 내의 실행 단위**
  - **stack만 고유한 영역을 갖고 나머지 영역은 프로세스 자원을 공유**
  - stack 이외의 영역을 공유하므로 동기화 작업이 필요
  - stack 이외의 영역을 공유하므로 컨텍스트 스위칭 비용이 적음

## 멀티스레드
  - **하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하면서 작업을 수행하는 것**
  - 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 작업이 필요하다

## 스레드 풀을 쓰는 이유

스레드 풀은 작업처리에 사용되는 스레드를 제한된 개수만큼 정해놓고 , 작업큐 (Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것을 말합니다. 

그렇게 하면 작업처리 요청이 폭증되어도 스레드의 전체개수가 늘어나지 않으므로(제한해서 하나씩 처리하기 때문) 시스템 성능이 급격히 저하되지 않는다.

## 인터럽트에 대해서 설명해주세요.

인터럽트란 프로그램을 실행하고 있는 도중에 입출력 요청 또는 예외상황 처리가 발생하면 실행하던 프로그램을 멈추고 CPU가 해당 작업을 처리하도록 하는 것을 의미한다.

## synchronized 에 대해서 설명해주세요.

동기화가 필요한 임계영역에 사용함으로써 스레드가 동시에 접근하지 못하도록 하는 것입니다.

synchronized로 지정된 임계영역은 한 스레드가 이 영역에 접근하여 사용할 때 lock이 걸림으로써 다른 스레드가 접근할 수 없게 됩니다. 이후 해당 스레드가 이 임계영역의 코드를 다 실행 후 벗어나게 되면 unlock 상태가 되어 그때서야 대기하고 있던 다른 스레드가 이 임계영역에 접근하여 다시  lock을 걸고 사용할 수 있게 됩니다.

lock은 해당 객체 당 하나씩 존재하며,synchrorized로 설정된 임계영역은 lock 권한을 얻은 하나의 객체만이 독점적으로 사용하게 됩니다.

## 동시성과 병렬성의 차이는?

| 동시성(Concurrency) | 병렬성(Parallelism) |
| --- | --- |
| 여러 작업이 동시에 실행되고 있는 것처럼 구현되는 것 | 여러 작업이 실제로 동시에 실행되고 있는 것 |
| 싱글 코어 환경에서 단일 프로세스 내에 멀티 스레드를 동작하여 구현 | 멀티 코어 환경에서 멀티 프로세스(단일 스레드) 혹은 멀티 스레드를 활용하여 처리. |
| 빠른 시간에 하나씩 많은 것을 처리 | 한번에 많은 것을 처리 |
| 논리적인 부분 | 물리적인 부분 |
| 예시)커피 추출구가 하나인 커피머신이 아메리카노, 라떼, 마끼야또를 재료를 바꿔가면서 동시에 만들어지도록 구현. | 예시)커피 추출구가 여러개인 커피머신이 동시에 각각의 재료를 통해 아메리카노, 라떼, 마끼야또를 만듬. |

## 동기와 비동기에 대해서 설명하고 장단점은 무엇인지 설명해주세요.

### 동기 Synchronous

- A 함수가 B 함수를 호출 할 때, B 함수의 결과를 A 함수가 처리하는 것.
- 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점

### 비동기 Asynchronous

- A 함수가 B 함수를 호출 할 때, B 함수의 결과를 B 함수가 처리하는 것. (callback)
- 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있다.

두 가지의 차이점은 **호출하는 함수가 호출되는 함수의 작업 완료 여부를 신경쓰는지 여부** 에 차이가 있다.

## 동기화는 왜 필요한가?

### 동기화란?

여러 프로세스/쓰레드가 공유하는 자원의 일관성(동시에 접근하지 못하도록 막는 것)을 유지하는 것=데이터의 일관성을 유지하기 위한 매커니즘이다. 동기화가 필요한 부분을 임계영역이라고 한다.

### 그럼 왜 필요한가?

멀티스레드(나 멀티프로세스에서 )환경에서 하나의 공유자원을 여러 스레드에서 동시에 접근하게 되면 예상치 못한 결과가 나타나기 때문이다.

- 프로세스 동기화
  - Critical Section
    - **동일한 자원에 접근하는 작업을 실행하는 코드 영역**을 의미한다.
    - 멀티 스레딩에 문제점에서 나오듯, 동일한 자원을 동시에 접근하는 작업(e.g. 공유하는 변수 사용, 동일 파일을 사용하는 등)을 실행하는 코드 영역을 Critical Section 이라 칭한다.
  - 해결책
    - 뮤텍스
    - 세마포어
    - 모니터

## 교착상태(deadlock) 의 발생조건과 교착상태를 깨는 방법은 무엇인지 설명해주세요.

• **두 개 이상의 프로세스나 스레드가 자원을 점유하면서 서로의 자원을 기다리며 무한히 대기하는 상태**
• 발생 조건
◦ 상호 배제
▪ 한 자원에 여러 프로세스가 동시에 접근할 수 없다.
◦ 점유 대기
▪ 하나의 자원을 소유한 상태에서 다른 자원을 기다린다.
◦ 비선점
▪ 프로세스가 어떤 자원의 사용을 끝낼 때까지 프로세스의 자원을 뺏을 수 없다.
◦ 순환 대기
▪ 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

해결방법

4가지 발생 조건 중 하나라도 제거하면 교착 상태를 막을 수 있다.공유 자원 중 많은 경우에 한 번에 한 프로세스 혹은 스레드만 접근할 수 있기 때문에 상호 배제 조건은 제거하기 어렵다.**대부분 교착 상태 방지 알고리즘은 순환 대기가 발생하는 것을 막는데 초점이 맞춰져 있다.**

• 예방(Prevention)
◦ 교착 상태 조건 중 하나라도 제거함으로 데드락이 발생하지 않도록 예방하는 방식

a-1. 상호 배제 조건 제거
- 모든 자원의 공유를 허용함.
  a-2. 점유 대기 조건 제거
- 필요한 모든 자원을 할당함.(자원 낭비 발생)
- 자원을 점유하고 있지 않을 때만 다른 자원을 요청할 수 있도록 함.(기아 상태 가능성)
  a-3. 비선점 조건 제거
- 할당 받을 수 없는 자원을 요청할 때 점유하고 있는 모든 자원을 반납하고 대기하게 함.(자원 낭비 발생)
  a-4. 순환대기 조건 제거
- 자원에 고유 번호를 매기고 번호 순서대로 특정 방향으로만 자원을 요구하도록 함.(자원 낭비 발생)

• 회피(Avoidance)

    ◦ 데드락이 빠질 가능성이 있는지 없는지 운영체제가 검사하면서 빠질 가능성이 없는 경우에만 자원을 할당함으로써 문제발생을 피하는 것입니다.
    ◦ **데드락 발생 가능성을 인정하면서도 적절하게 회피하는 방식**
    ◦ 은행원 알고리즘

은행원 알고리즘의 이름은 은행이 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야한다는 개념에서 나온 것이다.

        ▪ 프로세스가 자원을 요구할 때 시스템이 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하는 알고리즘
        ▪ 발생하지 않으면 자원을 할당하고, 발생하면 다른 프로세스가 자원을 해제할 때까지 대기한다.
        ▪ 안전상태: 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태
        ▪ 항상 안전 상태를 유지할 수 있다는 장점이 있으나 최대 자원 요구량을 미리 알아야 하고 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다.

• 탐지(Detection) 및 회복(Recovery)
◦ 은행원 알고리즘과 유사하게 탐지 알고리즘으로(시스템의 자원 할당 상태를 갖고) 데드락이 발생했는지 여부를 탐색한다.
◦ 탐지했다면 데드락을 회복한다.
▪ 데드락 상태의 프로세스 모두 중단시키기
▪ 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키기
▪ 자원 선점을 통해 해결하기(교착 상태에 있는 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에 할당)


## CPU 스케줄러-알고리즘 종류

- First Come First Served(FCFS)
  - 준비 큐에 도착한 순서대로 실행
  - 최악의 경우 오래 걸리는 문제가 가장 먼저 들어옴
- Shortest Job First (SJF)
  - CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식
  - **기아 문제** 발생
- Round Robin(RR)
  - 프로세스에게 각각 동일한 CPU할당 시간을 부여해서 이 시간동안만 CPU를 이용하게 한다.(선점형 방식)
- Shortest Remaining Time First (SRTF)
  - SJF의 선점형 방식으로 남은 처리시간이 짧은 프로세스 먼저 CPU를 할당한다
  - **기아 문제** 발생
- Priority scheduling
  - 프로세스의 중요도에 따라 매긴 우선순위를 반영한 알고리즘

## 메모리 관리 전략

- Paging
  - 한 프로세스가 사용하는 공간은 page라 불리는 고정 크기의 블록으로 나뉘어 관리되고,각각의 page는 순서와 관계없이 메모리의 frame에 mapping되어 저장된다.
  - page가 어느 frame에 들어있는지를 알아야하기 때문에 page table이 필요합니다.
  - 내부단편화가 생기는 단점이 있다.
- Segmentation
  - 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할하고 메모리에 배치하는 것을 말하며, 각 세그먼트의 크기는 일정하지 않는다.
  - 외부단편화 생긴다.

## 캐시

- 캐시 메모리
  - cpu와 메모리 사이에서 속도가 빠른 장치와 느린 장치 간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리다.
- 지역성 Locality
  - 시간 지역성
    - 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성
  - 공간 지역성
    - 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성
- Caching line
  - 데이터가 캐시 내의 어느 곳에 저장되어 있는지 찾기가 어려워 모든 데이터를 순회해야 한다면 캐시의 장점을 잃기 때문에 쉽게 찾을 수 있는 구조가 필요하다.
  - 캐시에 목적 데이터가 저장되어 있다면 바로 접근하여 출력할수 있어야 캐시가 의미가 있어진다. 따라서, 캐시에 저장하는 데이터에는 **데이터의 (메모리) 주소 등을 기록해 둔 태그**를 달아놓는데 이러한 **태그들의 묶음을 캐시라인**이라고 한다.